// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storetest

import (
	"context"
	"github.com/ONSdigital/dp-dataset-api/models"
	"github.com/ONSdigital/dp-dataset-api/store"
	"github.com/ONSdigital/dp-graph/observation"
	"github.com/globalsign/mgo/bson"
	"sync"
)

var (
	lockStorerMockAddDimensionToInstance            sync.RWMutex
	lockStorerMockAddEventToInstance                sync.RWMutex
	lockStorerMockAddInstance                       sync.RWMutex
	lockStorerMockAddVersionDetailsToInstance       sync.RWMutex
	lockStorerMockCheckDatasetExists                sync.RWMutex
	lockStorerMockCheckEditionExists                sync.RWMutex
	lockStorerMockDeleteDataset                     sync.RWMutex
	lockStorerMockDeleteEdition                     sync.RWMutex
	lockStorerMockGetDataset                        sync.RWMutex
	lockStorerMockGetDatasets                       sync.RWMutex
	lockStorerMockGetDimensionOptions               sync.RWMutex
	lockStorerMockGetDimensions                     sync.RWMutex
	lockStorerMockGetDimensionsFromInstance         sync.RWMutex
	lockStorerMockGetEdition                        sync.RWMutex
	lockStorerMockGetEditions                       sync.RWMutex
	lockStorerMockGetInstance                       sync.RWMutex
	lockStorerMockGetInstances                      sync.RWMutex
	lockStorerMockGetNextVersion                    sync.RWMutex
	lockStorerMockGetUniqueDimensionAndOptions      sync.RWMutex
	lockStorerMockGetVersion                        sync.RWMutex
	lockStorerMockGetVersions                       sync.RWMutex
	lockStorerMockSetInstanceIsPublished            sync.RWMutex
	lockStorerMockStreamCSVRows                     sync.RWMutex
	lockStorerMockUpdateBuildHierarchyTaskState     sync.RWMutex
	lockStorerMockUpdateBuildSearchTaskState        sync.RWMutex
	lockStorerMockUpdateDataset                     sync.RWMutex
	lockStorerMockUpdateDatasetWithAssociation      sync.RWMutex
	lockStorerMockUpdateDimensionNodeID             sync.RWMutex
	lockStorerMockUpdateImportObservationsTaskState sync.RWMutex
	lockStorerMockUpdateInstance                    sync.RWMutex
	lockStorerMockUpdateObservationInserted         sync.RWMutex
	lockStorerMockUpdateVersion                     sync.RWMutex
	lockStorerMockUpsertContact                     sync.RWMutex
	lockStorerMockUpsertDataset                     sync.RWMutex
	lockStorerMockUpsertEdition                     sync.RWMutex
	lockStorerMockUpsertVersion                     sync.RWMutex
)

// Ensure, that StorerMock does implement store.Storer.
// If this is not the case, regenerate this file with moq.
var _ store.Storer = &StorerMock{}

// StorerMock is a mock implementation of store.Storer.
//
//     func TestSomethingThatUsesStorer(t *testing.T) {
//
//         // make and configure a mocked store.Storer
//         mockedStorer := &StorerMock{
//             AddDimensionToInstanceFunc: func(dimension *models.CachedDimensionOption) error {
// 	               panic("mock out the AddDimensionToInstance method")
//             },
//             AddEventToInstanceFunc: func(instanceID string, event *models.Event) error {
// 	               panic("mock out the AddEventToInstance method")
//             },
//             AddInstanceFunc: func(instance *models.Instance) (*models.Instance, error) {
// 	               panic("mock out the AddInstance method")
//             },
//             AddVersionDetailsToInstanceFunc: func(ctx context.Context, instanceID string, datasetID string, edition string, version int) error {
// 	               panic("mock out the AddVersionDetailsToInstance method")
//             },
//             CheckDatasetExistsFunc: func(ID string, state string) error {
// 	               panic("mock out the CheckDatasetExists method")
//             },
//             CheckEditionExistsFunc: func(ID string, editionID string, state string) error {
// 	               panic("mock out the CheckEditionExists method")
//             },
//             DeleteDatasetFunc: func(ID string) error {
// 	               panic("mock out the DeleteDataset method")
//             },
//             DeleteEditionFunc: func(ID string) error {
// 	               panic("mock out the DeleteEdition method")
//             },
//             GetDatasetFunc: func(ID string) (*models.DatasetUpdate, error) {
// 	               panic("mock out the GetDataset method")
//             },
//             GetDatasetsFunc: func(ctx context.Context) ([]models.DatasetUpdate, error) {
// 	               panic("mock out the GetDatasets method")
//             },
//             GetDimensionOptionsFunc: func(version *models.Version, dimension string) (*models.DimensionOptionResults, error) {
// 	               panic("mock out the GetDimensionOptions method")
//             },
//             GetDimensionsFunc: func(datasetID string, versionID string) ([]bson.M, error) {
// 	               panic("mock out the GetDimensions method")
//             },
//             GetDimensionsFromInstanceFunc: func(ID string) (*models.DimensionNodeResults, error) {
// 	               panic("mock out the GetDimensionsFromInstance method")
//             },
//             GetEditionFunc: func(ID string, editionID string, state string) (*models.EditionUpdate, error) {
// 	               panic("mock out the GetEdition method")
//             },
//             GetEditionsFunc: func(ctx context.Context, ID string, state string) (*models.EditionUpdateResults, error) {
// 	               panic("mock out the GetEditions method")
//             },
//             GetInstanceFunc: func(ID string) (*models.Instance, error) {
// 	               panic("mock out the GetInstance method")
//             },
//             GetInstancesFunc: func(ctx context.Context, states []string, datasets []string) (*models.InstanceResults, error) {
// 	               panic("mock out the GetInstances method")
//             },
//             GetNextVersionFunc: func(datasetID string, editionID string) (int, error) {
// 	               panic("mock out the GetNextVersion method")
//             },
//             GetUniqueDimensionAndOptionsFunc: func(ID string, dimension string) (*models.DimensionValues, error) {
// 	               panic("mock out the GetUniqueDimensionAndOptions method")
//             },
//             GetVersionFunc: func(datasetID string, editionID string, version string, state string) (*models.Version, error) {
// 	               panic("mock out the GetVersion method")
//             },
//             GetVersionsFunc: func(ctx context.Context, datasetID string, editionID string, state string) (*models.VersionResults, error) {
// 	               panic("mock out the GetVersions method")
//             },
//             SetInstanceIsPublishedFunc: func(ctx context.Context, instanceID string) error {
// 	               panic("mock out the SetInstanceIsPublished method")
//             },
//             StreamCSVRowsFunc: func(ctx context.Context, filter *observation.Filter, limit *int) (observation.StreamRowReader, error) {
// 	               panic("mock out the StreamCSVRows method")
//             },
//             UpdateBuildHierarchyTaskStateFunc: func(id string, dimension string, state string) error {
// 	               panic("mock out the UpdateBuildHierarchyTaskState method")
//             },
//             UpdateBuildSearchTaskStateFunc: func(id string, dimension string, state string) error {
// 	               panic("mock out the UpdateBuildSearchTaskState method")
//             },
//             UpdateDatasetFunc: func(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error {
// 	               panic("mock out the UpdateDataset method")
//             },
//             UpdateDatasetWithAssociationFunc: func(ID string, state string, version *models.Version) error {
// 	               panic("mock out the UpdateDatasetWithAssociation method")
//             },
//             UpdateDimensionNodeIDFunc: func(dimension *models.DimensionOption) error {
// 	               panic("mock out the UpdateDimensionNodeID method")
//             },
//             UpdateImportObservationsTaskStateFunc: func(id string, state string) error {
// 	               panic("mock out the UpdateImportObservationsTaskState method")
//             },
//             UpdateInstanceFunc: func(ctx context.Context, ID string, instance *models.Instance) error {
// 	               panic("mock out the UpdateInstance method")
//             },
//             UpdateObservationInsertedFunc: func(ID string, observationInserted int64) error {
// 	               panic("mock out the UpdateObservationInserted method")
//             },
//             UpdateVersionFunc: func(ID string, version *models.Version) error {
// 	               panic("mock out the UpdateVersion method")
//             },
//             UpsertContactFunc: func(ID string, update interface{}) error {
// 	               panic("mock out the UpsertContact method")
//             },
//             UpsertDatasetFunc: func(ID string, datasetDoc *models.DatasetUpdate) error {
// 	               panic("mock out the UpsertDataset method")
//             },
//             UpsertEditionFunc: func(datasetID string, edition string, editionDoc *models.EditionUpdate) error {
// 	               panic("mock out the UpsertEdition method")
//             },
//             UpsertVersionFunc: func(ID string, versionDoc *models.Version) error {
// 	               panic("mock out the UpsertVersion method")
//             },
//         }
//
//         // use mockedStorer in code that requires store.Storer
//         // and then make assertions.
//
//     }
type StorerMock struct {
	// AddDimensionToInstanceFunc mocks the AddDimensionToInstance method.
	AddDimensionToInstanceFunc func(dimension *models.CachedDimensionOption) error

	// AddEventToInstanceFunc mocks the AddEventToInstance method.
	AddEventToInstanceFunc func(instanceID string, event *models.Event) error

	// AddInstanceFunc mocks the AddInstance method.
	AddInstanceFunc func(instance *models.Instance) (*models.Instance, error)

	// AddVersionDetailsToInstanceFunc mocks the AddVersionDetailsToInstance method.
	AddVersionDetailsToInstanceFunc func(ctx context.Context, instanceID string, datasetID string, edition string, version int) error

	// CheckDatasetExistsFunc mocks the CheckDatasetExists method.
	CheckDatasetExistsFunc func(ID string, state string) error

	// CheckEditionExistsFunc mocks the CheckEditionExists method.
	CheckEditionExistsFunc func(ID string, editionID string, state string) error

	// DeleteDatasetFunc mocks the DeleteDataset method.
	DeleteDatasetFunc func(ID string) error

	// DeleteEditionFunc mocks the DeleteEdition method.
	DeleteEditionFunc func(ID string) error

	// GetDatasetFunc mocks the GetDataset method.
	GetDatasetFunc func(ID string) (*models.DatasetUpdate, error)

	// GetDatasetsFunc mocks the GetDatasets method.
	GetDatasetsFunc func(ctx context.Context) ([]models.DatasetUpdate, error)

	// GetDimensionOptionsFunc mocks the GetDimensionOptions method.
	GetDimensionOptionsFunc func(version *models.Version, dimension string) (*models.DimensionOptionResults, error)

	// GetDimensionsFunc mocks the GetDimensions method.
	GetDimensionsFunc func(datasetID string, versionID string) ([]bson.M, error)

	// GetDimensionsFromInstanceFunc mocks the GetDimensionsFromInstance method.
	GetDimensionsFromInstanceFunc func(ID string) (*models.DimensionNodeResults, error)

	// GetEditionFunc mocks the GetEdition method.
	GetEditionFunc func(ID string, editionID string, state string) (*models.EditionUpdate, error)

	// GetEditionsFunc mocks the GetEditions method.
	GetEditionsFunc func(ctx context.Context, ID string, state string) (*models.EditionUpdateResults, error)

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(ID string) (*models.Instance, error)

	// GetInstancesFunc mocks the GetInstances method.
	GetInstancesFunc func(ctx context.Context, states []string, datasets []string) (*models.InstanceResults, error)

	// GetNextVersionFunc mocks the GetNextVersion method.
	GetNextVersionFunc func(datasetID string, editionID string) (int, error)

	// GetUniqueDimensionAndOptionsFunc mocks the GetUniqueDimensionAndOptions method.
	GetUniqueDimensionAndOptionsFunc func(ID string, dimension string) (*models.DimensionValues, error)

	// GetVersionFunc mocks the GetVersion method.
	GetVersionFunc func(datasetID string, editionID string, version string, state string) (*models.Version, error)

	// GetVersionsFunc mocks the GetVersions method.
	GetVersionsFunc func(ctx context.Context, datasetID string, editionID string, state string) (*models.VersionResults, error)

	// SetInstanceIsPublishedFunc mocks the SetInstanceIsPublished method.
	SetInstanceIsPublishedFunc func(ctx context.Context, instanceID string) error

	// StreamCSVRowsFunc mocks the StreamCSVRows method.
	StreamCSVRowsFunc func(ctx context.Context, filter *observation.Filter, limit *int) (observation.StreamRowReader, error)

	// UpdateBuildHierarchyTaskStateFunc mocks the UpdateBuildHierarchyTaskState method.
	UpdateBuildHierarchyTaskStateFunc func(id string, dimension string, state string) error

	// UpdateBuildSearchTaskStateFunc mocks the UpdateBuildSearchTaskState method.
	UpdateBuildSearchTaskStateFunc func(id string, dimension string, state string) error

	// UpdateDatasetFunc mocks the UpdateDataset method.
	UpdateDatasetFunc func(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error

	// UpdateDatasetWithAssociationFunc mocks the UpdateDatasetWithAssociation method.
	UpdateDatasetWithAssociationFunc func(ID string, state string, version *models.Version) error

	// UpdateDimensionNodeIDFunc mocks the UpdateDimensionNodeID method.
	UpdateDimensionNodeIDFunc func(dimension *models.DimensionOption) error

	// UpdateImportObservationsTaskStateFunc mocks the UpdateImportObservationsTaskState method.
	UpdateImportObservationsTaskStateFunc func(id string, state string) error

	// UpdateInstanceFunc mocks the UpdateInstance method.
	UpdateInstanceFunc func(ctx context.Context, ID string, instance *models.Instance) error

	// UpdateObservationInsertedFunc mocks the UpdateObservationInserted method.
	UpdateObservationInsertedFunc func(ID string, observationInserted int64) error

	// UpdateVersionFunc mocks the UpdateVersion method.
	UpdateVersionFunc func(ID string, version *models.Version) error

	// UpsertContactFunc mocks the UpsertContact method.
	UpsertContactFunc func(ID string, update interface{}) error

	// UpsertDatasetFunc mocks the UpsertDataset method.
	UpsertDatasetFunc func(ID string, datasetDoc *models.DatasetUpdate) error

	// UpsertEditionFunc mocks the UpsertEdition method.
	UpsertEditionFunc func(datasetID string, edition string, editionDoc *models.EditionUpdate) error

	// UpsertVersionFunc mocks the UpsertVersion method.
	UpsertVersionFunc func(ID string, versionDoc *models.Version) error

	// calls tracks calls to the methods.
	calls struct {
		// AddDimensionToInstance holds details about calls to the AddDimensionToInstance method.
		AddDimensionToInstance []struct {
			// Dimension is the dimension argument value.
			Dimension *models.CachedDimensionOption
		}
		// AddEventToInstance holds details about calls to the AddEventToInstance method.
		AddEventToInstance []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Event is the event argument value.
			Event *models.Event
		}
		// AddInstance holds details about calls to the AddInstance method.
		AddInstance []struct {
			// Instance is the instance argument value.
			Instance *models.Instance
		}
		// AddVersionDetailsToInstance holds details about calls to the AddVersionDetailsToInstance method.
		AddVersionDetailsToInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version int
		}
		// CheckDatasetExists holds details about calls to the CheckDatasetExists method.
		CheckDatasetExists []struct {
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
		}
		// CheckEditionExists holds details about calls to the CheckEditionExists method.
		CheckEditionExists []struct {
			// ID is the ID argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// DeleteDataset holds details about calls to the DeleteDataset method.
		DeleteDataset []struct {
			// ID is the ID argument value.
			ID string
		}
		// DeleteEdition holds details about calls to the DeleteEdition method.
		DeleteEdition []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetDataset holds details about calls to the GetDataset method.
		GetDataset []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetDatasets holds details about calls to the GetDatasets method.
		GetDatasets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetDimensionOptions holds details about calls to the GetDimensionOptions method.
		GetDimensionOptions []struct {
			// Version is the version argument value.
			Version *models.Version
			// Dimension is the dimension argument value.
			Dimension string
		}
		// GetDimensions holds details about calls to the GetDimensions method.
		GetDimensions []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// VersionID is the versionID argument value.
			VersionID string
		}
		// GetDimensionsFromInstance holds details about calls to the GetDimensionsFromInstance method.
		GetDimensionsFromInstance []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetEdition holds details about calls to the GetEdition method.
		GetEdition []struct {
			// ID is the ID argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// GetEditions holds details about calls to the GetEditions method.
		GetEditions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetInstances holds details about calls to the GetInstances method.
		GetInstances []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// States is the states argument value.
			States []string
			// Datasets is the datasets argument value.
			Datasets []string
		}
		// GetNextVersion holds details about calls to the GetNextVersion method.
		GetNextVersion []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
		}
		// GetUniqueDimensionAndOptions holds details about calls to the GetUniqueDimensionAndOptions method.
		GetUniqueDimensionAndOptions []struct {
			// ID is the ID argument value.
			ID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// GetVersion holds details about calls to the GetVersion method.
		GetVersion []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// Version is the version argument value.
			Version string
			// State is the state argument value.
			State string
		}
		// GetVersions holds details about calls to the GetVersions method.
		GetVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// SetInstanceIsPublished holds details about calls to the SetInstanceIsPublished method.
		SetInstanceIsPublished []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// StreamCSVRows holds details about calls to the StreamCSVRows method.
		StreamCSVRows []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter *observation.Filter
			// Limit is the limit argument value.
			Limit *int
		}
		// UpdateBuildHierarchyTaskState holds details about calls to the UpdateBuildHierarchyTaskState method.
		UpdateBuildHierarchyTaskState []struct {
			// ID is the id argument value.
			ID string
			// Dimension is the dimension argument value.
			Dimension string
			// State is the state argument value.
			State string
		}
		// UpdateBuildSearchTaskState holds details about calls to the UpdateBuildSearchTaskState method.
		UpdateBuildSearchTaskState []struct {
			// ID is the id argument value.
			ID string
			// Dimension is the dimension argument value.
			Dimension string
			// State is the state argument value.
			State string
		}
		// UpdateDataset holds details about calls to the UpdateDataset method.
		UpdateDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Dataset is the dataset argument value.
			Dataset *models.Dataset
			// CurrentState is the currentState argument value.
			CurrentState string
		}
		// UpdateDatasetWithAssociation holds details about calls to the UpdateDatasetWithAssociation method.
		UpdateDatasetWithAssociation []struct {
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
			// Version is the version argument value.
			Version *models.Version
		}
		// UpdateDimensionNodeID holds details about calls to the UpdateDimensionNodeID method.
		UpdateDimensionNodeID []struct {
			// Dimension is the dimension argument value.
			Dimension *models.DimensionOption
		}
		// UpdateImportObservationsTaskState holds details about calls to the UpdateImportObservationsTaskState method.
		UpdateImportObservationsTaskState []struct {
			// ID is the id argument value.
			ID string
			// State is the state argument value.
			State string
		}
		// UpdateInstance holds details about calls to the UpdateInstance method.
		UpdateInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Instance is the instance argument value.
			Instance *models.Instance
		}
		// UpdateObservationInserted holds details about calls to the UpdateObservationInserted method.
		UpdateObservationInserted []struct {
			// ID is the ID argument value.
			ID string
			// ObservationInserted is the observationInserted argument value.
			ObservationInserted int64
		}
		// UpdateVersion holds details about calls to the UpdateVersion method.
		UpdateVersion []struct {
			// ID is the ID argument value.
			ID string
			// Version is the version argument value.
			Version *models.Version
		}
		// UpsertContact holds details about calls to the UpsertContact method.
		UpsertContact []struct {
			// ID is the ID argument value.
			ID string
			// Update is the update argument value.
			Update interface{}
		}
		// UpsertDataset holds details about calls to the UpsertDataset method.
		UpsertDataset []struct {
			// ID is the ID argument value.
			ID string
			// DatasetDoc is the datasetDoc argument value.
			DatasetDoc *models.DatasetUpdate
		}
		// UpsertEdition holds details about calls to the UpsertEdition method.
		UpsertEdition []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// EditionDoc is the editionDoc argument value.
			EditionDoc *models.EditionUpdate
		}
		// UpsertVersion holds details about calls to the UpsertVersion method.
		UpsertVersion []struct {
			// ID is the ID argument value.
			ID string
			// VersionDoc is the versionDoc argument value.
			VersionDoc *models.Version
		}
	}
}

// AddDimensionToInstance calls AddDimensionToInstanceFunc.
func (mock *StorerMock) AddDimensionToInstance(dimension *models.CachedDimensionOption) error {
	if mock.AddDimensionToInstanceFunc == nil {
		panic("StorerMock.AddDimensionToInstanceFunc: method is nil but Storer.AddDimensionToInstance was just called")
	}
	callInfo := struct {
		Dimension *models.CachedDimensionOption
	}{
		Dimension: dimension,
	}
	lockStorerMockAddDimensionToInstance.Lock()
	mock.calls.AddDimensionToInstance = append(mock.calls.AddDimensionToInstance, callInfo)
	lockStorerMockAddDimensionToInstance.Unlock()
	return mock.AddDimensionToInstanceFunc(dimension)
}

// AddDimensionToInstanceCalls gets all the calls that were made to AddDimensionToInstance.
// Check the length with:
//     len(mockedStorer.AddDimensionToInstanceCalls())
func (mock *StorerMock) AddDimensionToInstanceCalls() []struct {
	Dimension *models.CachedDimensionOption
} {
	var calls []struct {
		Dimension *models.CachedDimensionOption
	}
	lockStorerMockAddDimensionToInstance.RLock()
	calls = mock.calls.AddDimensionToInstance
	lockStorerMockAddDimensionToInstance.RUnlock()
	return calls
}

// AddEventToInstance calls AddEventToInstanceFunc.
func (mock *StorerMock) AddEventToInstance(instanceID string, event *models.Event) error {
	if mock.AddEventToInstanceFunc == nil {
		panic("StorerMock.AddEventToInstanceFunc: method is nil but Storer.AddEventToInstance was just called")
	}
	callInfo := struct {
		InstanceID string
		Event      *models.Event
	}{
		InstanceID: instanceID,
		Event:      event,
	}
	lockStorerMockAddEventToInstance.Lock()
	mock.calls.AddEventToInstance = append(mock.calls.AddEventToInstance, callInfo)
	lockStorerMockAddEventToInstance.Unlock()
	return mock.AddEventToInstanceFunc(instanceID, event)
}

// AddEventToInstanceCalls gets all the calls that were made to AddEventToInstance.
// Check the length with:
//     len(mockedStorer.AddEventToInstanceCalls())
func (mock *StorerMock) AddEventToInstanceCalls() []struct {
	InstanceID string
	Event      *models.Event
} {
	var calls []struct {
		InstanceID string
		Event      *models.Event
	}
	lockStorerMockAddEventToInstance.RLock()
	calls = mock.calls.AddEventToInstance
	lockStorerMockAddEventToInstance.RUnlock()
	return calls
}

// AddInstance calls AddInstanceFunc.
func (mock *StorerMock) AddInstance(instance *models.Instance) (*models.Instance, error) {
	if mock.AddInstanceFunc == nil {
		panic("StorerMock.AddInstanceFunc: method is nil but Storer.AddInstance was just called")
	}
	callInfo := struct {
		Instance *models.Instance
	}{
		Instance: instance,
	}
	lockStorerMockAddInstance.Lock()
	mock.calls.AddInstance = append(mock.calls.AddInstance, callInfo)
	lockStorerMockAddInstance.Unlock()
	return mock.AddInstanceFunc(instance)
}

// AddInstanceCalls gets all the calls that were made to AddInstance.
// Check the length with:
//     len(mockedStorer.AddInstanceCalls())
func (mock *StorerMock) AddInstanceCalls() []struct {
	Instance *models.Instance
} {
	var calls []struct {
		Instance *models.Instance
	}
	lockStorerMockAddInstance.RLock()
	calls = mock.calls.AddInstance
	lockStorerMockAddInstance.RUnlock()
	return calls
}

// AddVersionDetailsToInstance calls AddVersionDetailsToInstanceFunc.
func (mock *StorerMock) AddVersionDetailsToInstance(ctx context.Context, instanceID string, datasetID string, edition string, version int) error {
	if mock.AddVersionDetailsToInstanceFunc == nil {
		panic("StorerMock.AddVersionDetailsToInstanceFunc: method is nil but Storer.AddVersionDetailsToInstance was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		DatasetID  string
		Edition    string
		Version    int
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		DatasetID:  datasetID,
		Edition:    edition,
		Version:    version,
	}
	lockStorerMockAddVersionDetailsToInstance.Lock()
	mock.calls.AddVersionDetailsToInstance = append(mock.calls.AddVersionDetailsToInstance, callInfo)
	lockStorerMockAddVersionDetailsToInstance.Unlock()
	return mock.AddVersionDetailsToInstanceFunc(ctx, instanceID, datasetID, edition, version)
}

// AddVersionDetailsToInstanceCalls gets all the calls that were made to AddVersionDetailsToInstance.
// Check the length with:
//     len(mockedStorer.AddVersionDetailsToInstanceCalls())
func (mock *StorerMock) AddVersionDetailsToInstanceCalls() []struct {
	Ctx        context.Context
	InstanceID string
	DatasetID  string
	Edition    string
	Version    int
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		DatasetID  string
		Edition    string
		Version    int
	}
	lockStorerMockAddVersionDetailsToInstance.RLock()
	calls = mock.calls.AddVersionDetailsToInstance
	lockStorerMockAddVersionDetailsToInstance.RUnlock()
	return calls
}

// CheckDatasetExists calls CheckDatasetExistsFunc.
func (mock *StorerMock) CheckDatasetExists(ID string, state string) error {
	if mock.CheckDatasetExistsFunc == nil {
		panic("StorerMock.CheckDatasetExistsFunc: method is nil but Storer.CheckDatasetExists was just called")
	}
	callInfo := struct {
		ID    string
		State string
	}{
		ID:    ID,
		State: state,
	}
	lockStorerMockCheckDatasetExists.Lock()
	mock.calls.CheckDatasetExists = append(mock.calls.CheckDatasetExists, callInfo)
	lockStorerMockCheckDatasetExists.Unlock()
	return mock.CheckDatasetExistsFunc(ID, state)
}

// CheckDatasetExistsCalls gets all the calls that were made to CheckDatasetExists.
// Check the length with:
//     len(mockedStorer.CheckDatasetExistsCalls())
func (mock *StorerMock) CheckDatasetExistsCalls() []struct {
	ID    string
	State string
} {
	var calls []struct {
		ID    string
		State string
	}
	lockStorerMockCheckDatasetExists.RLock()
	calls = mock.calls.CheckDatasetExists
	lockStorerMockCheckDatasetExists.RUnlock()
	return calls
}

// CheckEditionExists calls CheckEditionExistsFunc.
func (mock *StorerMock) CheckEditionExists(ID string, editionID string, state string) error {
	if mock.CheckEditionExistsFunc == nil {
		panic("StorerMock.CheckEditionExistsFunc: method is nil but Storer.CheckEditionExists was just called")
	}
	callInfo := struct {
		ID        string
		EditionID string
		State     string
	}{
		ID:        ID,
		EditionID: editionID,
		State:     state,
	}
	lockStorerMockCheckEditionExists.Lock()
	mock.calls.CheckEditionExists = append(mock.calls.CheckEditionExists, callInfo)
	lockStorerMockCheckEditionExists.Unlock()
	return mock.CheckEditionExistsFunc(ID, editionID, state)
}

// CheckEditionExistsCalls gets all the calls that were made to CheckEditionExists.
// Check the length with:
//     len(mockedStorer.CheckEditionExistsCalls())
func (mock *StorerMock) CheckEditionExistsCalls() []struct {
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		ID        string
		EditionID string
		State     string
	}
	lockStorerMockCheckEditionExists.RLock()
	calls = mock.calls.CheckEditionExists
	lockStorerMockCheckEditionExists.RUnlock()
	return calls
}

// DeleteDataset calls DeleteDatasetFunc.
func (mock *StorerMock) DeleteDataset(ID string) error {
	if mock.DeleteDatasetFunc == nil {
		panic("StorerMock.DeleteDatasetFunc: method is nil but Storer.DeleteDataset was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockStorerMockDeleteDataset.Lock()
	mock.calls.DeleteDataset = append(mock.calls.DeleteDataset, callInfo)
	lockStorerMockDeleteDataset.Unlock()
	return mock.DeleteDatasetFunc(ID)
}

// DeleteDatasetCalls gets all the calls that were made to DeleteDataset.
// Check the length with:
//     len(mockedStorer.DeleteDatasetCalls())
func (mock *StorerMock) DeleteDatasetCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStorerMockDeleteDataset.RLock()
	calls = mock.calls.DeleteDataset
	lockStorerMockDeleteDataset.RUnlock()
	return calls
}

// DeleteEdition calls DeleteEditionFunc.
func (mock *StorerMock) DeleteEdition(ID string) error {
	if mock.DeleteEditionFunc == nil {
		panic("StorerMock.DeleteEditionFunc: method is nil but Storer.DeleteEdition was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockStorerMockDeleteEdition.Lock()
	mock.calls.DeleteEdition = append(mock.calls.DeleteEdition, callInfo)
	lockStorerMockDeleteEdition.Unlock()
	return mock.DeleteEditionFunc(ID)
}

// DeleteEditionCalls gets all the calls that were made to DeleteEdition.
// Check the length with:
//     len(mockedStorer.DeleteEditionCalls())
func (mock *StorerMock) DeleteEditionCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStorerMockDeleteEdition.RLock()
	calls = mock.calls.DeleteEdition
	lockStorerMockDeleteEdition.RUnlock()
	return calls
}

// GetDataset calls GetDatasetFunc.
func (mock *StorerMock) GetDataset(ID string) (*models.DatasetUpdate, error) {
	if mock.GetDatasetFunc == nil {
		panic("StorerMock.GetDatasetFunc: method is nil but Storer.GetDataset was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockStorerMockGetDataset.Lock()
	mock.calls.GetDataset = append(mock.calls.GetDataset, callInfo)
	lockStorerMockGetDataset.Unlock()
	return mock.GetDatasetFunc(ID)
}

// GetDatasetCalls gets all the calls that were made to GetDataset.
// Check the length with:
//     len(mockedStorer.GetDatasetCalls())
func (mock *StorerMock) GetDatasetCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStorerMockGetDataset.RLock()
	calls = mock.calls.GetDataset
	lockStorerMockGetDataset.RUnlock()
	return calls
}

// GetDatasets calls GetDatasetsFunc.
func (mock *StorerMock) GetDatasets(ctx context.Context) ([]models.DatasetUpdate, error) {
	if mock.GetDatasetsFunc == nil {
		panic("StorerMock.GetDatasetsFunc: method is nil but Storer.GetDatasets was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	lockStorerMockGetDatasets.Lock()
	mock.calls.GetDatasets = append(mock.calls.GetDatasets, callInfo)
	lockStorerMockGetDatasets.Unlock()
	return mock.GetDatasetsFunc(ctx)
}

// GetDatasetsCalls gets all the calls that were made to GetDatasets.
// Check the length with:
//     len(mockedStorer.GetDatasetsCalls())
func (mock *StorerMock) GetDatasetsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	lockStorerMockGetDatasets.RLock()
	calls = mock.calls.GetDatasets
	lockStorerMockGetDatasets.RUnlock()
	return calls
}

// GetDimensionOptions calls GetDimensionOptionsFunc.
func (mock *StorerMock) GetDimensionOptions(version *models.Version, dimension string) (*models.DimensionOptionResults, error) {
	if mock.GetDimensionOptionsFunc == nil {
		panic("StorerMock.GetDimensionOptionsFunc: method is nil but Storer.GetDimensionOptions was just called")
	}
	callInfo := struct {
		Version   *models.Version
		Dimension string
	}{
		Version:   version,
		Dimension: dimension,
	}
	lockStorerMockGetDimensionOptions.Lock()
	mock.calls.GetDimensionOptions = append(mock.calls.GetDimensionOptions, callInfo)
	lockStorerMockGetDimensionOptions.Unlock()
	return mock.GetDimensionOptionsFunc(version, dimension)
}

// GetDimensionOptionsCalls gets all the calls that were made to GetDimensionOptions.
// Check the length with:
//     len(mockedStorer.GetDimensionOptionsCalls())
func (mock *StorerMock) GetDimensionOptionsCalls() []struct {
	Version   *models.Version
	Dimension string
} {
	var calls []struct {
		Version   *models.Version
		Dimension string
	}
	lockStorerMockGetDimensionOptions.RLock()
	calls = mock.calls.GetDimensionOptions
	lockStorerMockGetDimensionOptions.RUnlock()
	return calls
}

// GetDimensions calls GetDimensionsFunc.
func (mock *StorerMock) GetDimensions(datasetID string, versionID string) ([]bson.M, error) {
	if mock.GetDimensionsFunc == nil {
		panic("StorerMock.GetDimensionsFunc: method is nil but Storer.GetDimensions was just called")
	}
	callInfo := struct {
		DatasetID string
		VersionID string
	}{
		DatasetID: datasetID,
		VersionID: versionID,
	}
	lockStorerMockGetDimensions.Lock()
	mock.calls.GetDimensions = append(mock.calls.GetDimensions, callInfo)
	lockStorerMockGetDimensions.Unlock()
	return mock.GetDimensionsFunc(datasetID, versionID)
}

// GetDimensionsCalls gets all the calls that were made to GetDimensions.
// Check the length with:
//     len(mockedStorer.GetDimensionsCalls())
func (mock *StorerMock) GetDimensionsCalls() []struct {
	DatasetID string
	VersionID string
} {
	var calls []struct {
		DatasetID string
		VersionID string
	}
	lockStorerMockGetDimensions.RLock()
	calls = mock.calls.GetDimensions
	lockStorerMockGetDimensions.RUnlock()
	return calls
}

// GetDimensionsFromInstance calls GetDimensionsFromInstanceFunc.
func (mock *StorerMock) GetDimensionsFromInstance(ID string) (*models.DimensionNodeResults, error) {
	if mock.GetDimensionsFromInstanceFunc == nil {
		panic("StorerMock.GetDimensionsFromInstanceFunc: method is nil but Storer.GetDimensionsFromInstance was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockStorerMockGetDimensionsFromInstance.Lock()
	mock.calls.GetDimensionsFromInstance = append(mock.calls.GetDimensionsFromInstance, callInfo)
	lockStorerMockGetDimensionsFromInstance.Unlock()
	return mock.GetDimensionsFromInstanceFunc(ID)
}

// GetDimensionsFromInstanceCalls gets all the calls that were made to GetDimensionsFromInstance.
// Check the length with:
//     len(mockedStorer.GetDimensionsFromInstanceCalls())
func (mock *StorerMock) GetDimensionsFromInstanceCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStorerMockGetDimensionsFromInstance.RLock()
	calls = mock.calls.GetDimensionsFromInstance
	lockStorerMockGetDimensionsFromInstance.RUnlock()
	return calls
}

// GetEdition calls GetEditionFunc.
func (mock *StorerMock) GetEdition(ID string, editionID string, state string) (*models.EditionUpdate, error) {
	if mock.GetEditionFunc == nil {
		panic("StorerMock.GetEditionFunc: method is nil but Storer.GetEdition was just called")
	}
	callInfo := struct {
		ID        string
		EditionID string
		State     string
	}{
		ID:        ID,
		EditionID: editionID,
		State:     state,
	}
	lockStorerMockGetEdition.Lock()
	mock.calls.GetEdition = append(mock.calls.GetEdition, callInfo)
	lockStorerMockGetEdition.Unlock()
	return mock.GetEditionFunc(ID, editionID, state)
}

// GetEditionCalls gets all the calls that were made to GetEdition.
// Check the length with:
//     len(mockedStorer.GetEditionCalls())
func (mock *StorerMock) GetEditionCalls() []struct {
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		ID        string
		EditionID string
		State     string
	}
	lockStorerMockGetEdition.RLock()
	calls = mock.calls.GetEdition
	lockStorerMockGetEdition.RUnlock()
	return calls
}

// GetEditions calls GetEditionsFunc.
func (mock *StorerMock) GetEditions(ctx context.Context, ID string, state string) (*models.EditionUpdateResults, error) {
	if mock.GetEditionsFunc == nil {
		panic("StorerMock.GetEditionsFunc: method is nil but Storer.GetEditions was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ID    string
		State string
	}{
		Ctx:   ctx,
		ID:    ID,
		State: state,
	}
	lockStorerMockGetEditions.Lock()
	mock.calls.GetEditions = append(mock.calls.GetEditions, callInfo)
	lockStorerMockGetEditions.Unlock()
	return mock.GetEditionsFunc(ctx, ID, state)
}

// GetEditionsCalls gets all the calls that were made to GetEditions.
// Check the length with:
//     len(mockedStorer.GetEditionsCalls())
func (mock *StorerMock) GetEditionsCalls() []struct {
	Ctx   context.Context
	ID    string
	State string
} {
	var calls []struct {
		Ctx   context.Context
		ID    string
		State string
	}
	lockStorerMockGetEditions.RLock()
	calls = mock.calls.GetEditions
	lockStorerMockGetEditions.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *StorerMock) GetInstance(ID string) (*models.Instance, error) {
	if mock.GetInstanceFunc == nil {
		panic("StorerMock.GetInstanceFunc: method is nil but Storer.GetInstance was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockStorerMockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	lockStorerMockGetInstance.Unlock()
	return mock.GetInstanceFunc(ID)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//     len(mockedStorer.GetInstanceCalls())
func (mock *StorerMock) GetInstanceCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStorerMockGetInstance.RLock()
	calls = mock.calls.GetInstance
	lockStorerMockGetInstance.RUnlock()
	return calls
}

// GetInstances calls GetInstancesFunc.
func (mock *StorerMock) GetInstances(ctx context.Context, states []string, datasets []string) (*models.InstanceResults, error) {
	if mock.GetInstancesFunc == nil {
		panic("StorerMock.GetInstancesFunc: method is nil but Storer.GetInstances was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		States   []string
		Datasets []string
	}{
		Ctx:      ctx,
		States:   states,
		Datasets: datasets,
	}
	lockStorerMockGetInstances.Lock()
	mock.calls.GetInstances = append(mock.calls.GetInstances, callInfo)
	lockStorerMockGetInstances.Unlock()
	return mock.GetInstancesFunc(ctx, states, datasets)
}

// GetInstancesCalls gets all the calls that were made to GetInstances.
// Check the length with:
//     len(mockedStorer.GetInstancesCalls())
func (mock *StorerMock) GetInstancesCalls() []struct {
	Ctx      context.Context
	States   []string
	Datasets []string
} {
	var calls []struct {
		Ctx      context.Context
		States   []string
		Datasets []string
	}
	lockStorerMockGetInstances.RLock()
	calls = mock.calls.GetInstances
	lockStorerMockGetInstances.RUnlock()
	return calls
}

// GetNextVersion calls GetNextVersionFunc.
func (mock *StorerMock) GetNextVersion(datasetID string, editionID string) (int, error) {
	if mock.GetNextVersionFunc == nil {
		panic("StorerMock.GetNextVersionFunc: method is nil but Storer.GetNextVersion was just called")
	}
	callInfo := struct {
		DatasetID string
		EditionID string
	}{
		DatasetID: datasetID,
		EditionID: editionID,
	}
	lockStorerMockGetNextVersion.Lock()
	mock.calls.GetNextVersion = append(mock.calls.GetNextVersion, callInfo)
	lockStorerMockGetNextVersion.Unlock()
	return mock.GetNextVersionFunc(datasetID, editionID)
}

// GetNextVersionCalls gets all the calls that were made to GetNextVersion.
// Check the length with:
//     len(mockedStorer.GetNextVersionCalls())
func (mock *StorerMock) GetNextVersionCalls() []struct {
	DatasetID string
	EditionID string
} {
	var calls []struct {
		DatasetID string
		EditionID string
	}
	lockStorerMockGetNextVersion.RLock()
	calls = mock.calls.GetNextVersion
	lockStorerMockGetNextVersion.RUnlock()
	return calls
}

// GetUniqueDimensionAndOptions calls GetUniqueDimensionAndOptionsFunc.
func (mock *StorerMock) GetUniqueDimensionAndOptions(ID string, dimension string) (*models.DimensionValues, error) {
	if mock.GetUniqueDimensionAndOptionsFunc == nil {
		panic("StorerMock.GetUniqueDimensionAndOptionsFunc: method is nil but Storer.GetUniqueDimensionAndOptions was just called")
	}
	callInfo := struct {
		ID        string
		Dimension string
	}{
		ID:        ID,
		Dimension: dimension,
	}
	lockStorerMockGetUniqueDimensionAndOptions.Lock()
	mock.calls.GetUniqueDimensionAndOptions = append(mock.calls.GetUniqueDimensionAndOptions, callInfo)
	lockStorerMockGetUniqueDimensionAndOptions.Unlock()
	return mock.GetUniqueDimensionAndOptionsFunc(ID, dimension)
}

// GetUniqueDimensionAndOptionsCalls gets all the calls that were made to GetUniqueDimensionAndOptions.
// Check the length with:
//     len(mockedStorer.GetUniqueDimensionAndOptionsCalls())
func (mock *StorerMock) GetUniqueDimensionAndOptionsCalls() []struct {
	ID        string
	Dimension string
} {
	var calls []struct {
		ID        string
		Dimension string
	}
	lockStorerMockGetUniqueDimensionAndOptions.RLock()
	calls = mock.calls.GetUniqueDimensionAndOptions
	lockStorerMockGetUniqueDimensionAndOptions.RUnlock()
	return calls
}

// GetVersion calls GetVersionFunc.
func (mock *StorerMock) GetVersion(datasetID string, editionID string, version string, state string) (*models.Version, error) {
	if mock.GetVersionFunc == nil {
		panic("StorerMock.GetVersionFunc: method is nil but Storer.GetVersion was just called")
	}
	callInfo := struct {
		DatasetID string
		EditionID string
		Version   string
		State     string
	}{
		DatasetID: datasetID,
		EditionID: editionID,
		Version:   version,
		State:     state,
	}
	lockStorerMockGetVersion.Lock()
	mock.calls.GetVersion = append(mock.calls.GetVersion, callInfo)
	lockStorerMockGetVersion.Unlock()
	return mock.GetVersionFunc(datasetID, editionID, version, state)
}

// GetVersionCalls gets all the calls that were made to GetVersion.
// Check the length with:
//     len(mockedStorer.GetVersionCalls())
func (mock *StorerMock) GetVersionCalls() []struct {
	DatasetID string
	EditionID string
	Version   string
	State     string
} {
	var calls []struct {
		DatasetID string
		EditionID string
		Version   string
		State     string
	}
	lockStorerMockGetVersion.RLock()
	calls = mock.calls.GetVersion
	lockStorerMockGetVersion.RUnlock()
	return calls
}

// GetVersions calls GetVersionsFunc.
func (mock *StorerMock) GetVersions(ctx context.Context, datasetID string, editionID string, state string) (*models.VersionResults, error) {
	if mock.GetVersionsFunc == nil {
		panic("StorerMock.GetVersionsFunc: method is nil but Storer.GetVersions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		State:     state,
	}
	lockStorerMockGetVersions.Lock()
	mock.calls.GetVersions = append(mock.calls.GetVersions, callInfo)
	lockStorerMockGetVersions.Unlock()
	return mock.GetVersionsFunc(ctx, datasetID, editionID, state)
}

// GetVersionsCalls gets all the calls that were made to GetVersions.
// Check the length with:
//     len(mockedStorer.GetVersionsCalls())
func (mock *StorerMock) GetVersionsCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
	}
	lockStorerMockGetVersions.RLock()
	calls = mock.calls.GetVersions
	lockStorerMockGetVersions.RUnlock()
	return calls
}

// SetInstanceIsPublished calls SetInstanceIsPublishedFunc.
func (mock *StorerMock) SetInstanceIsPublished(ctx context.Context, instanceID string) error {
	if mock.SetInstanceIsPublishedFunc == nil {
		panic("StorerMock.SetInstanceIsPublishedFunc: method is nil but Storer.SetInstanceIsPublished was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
	}
	lockStorerMockSetInstanceIsPublished.Lock()
	mock.calls.SetInstanceIsPublished = append(mock.calls.SetInstanceIsPublished, callInfo)
	lockStorerMockSetInstanceIsPublished.Unlock()
	return mock.SetInstanceIsPublishedFunc(ctx, instanceID)
}

// SetInstanceIsPublishedCalls gets all the calls that were made to SetInstanceIsPublished.
// Check the length with:
//     len(mockedStorer.SetInstanceIsPublishedCalls())
func (mock *StorerMock) SetInstanceIsPublishedCalls() []struct {
	Ctx        context.Context
	InstanceID string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
	}
	lockStorerMockSetInstanceIsPublished.RLock()
	calls = mock.calls.SetInstanceIsPublished
	lockStorerMockSetInstanceIsPublished.RUnlock()
	return calls
}

// StreamCSVRows calls StreamCSVRowsFunc.
func (mock *StorerMock) StreamCSVRows(ctx context.Context, filter *observation.Filter, limit *int) (observation.StreamRowReader, error) {
	if mock.StreamCSVRowsFunc == nil {
		panic("StorerMock.StreamCSVRowsFunc: method is nil but Storer.StreamCSVRows was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter *observation.Filter
		Limit  *int
	}{
		Ctx:    ctx,
		Filter: filter,
		Limit:  limit,
	}
	lockStorerMockStreamCSVRows.Lock()
	mock.calls.StreamCSVRows = append(mock.calls.StreamCSVRows, callInfo)
	lockStorerMockStreamCSVRows.Unlock()
	return mock.StreamCSVRowsFunc(ctx, filter, limit)
}

// StreamCSVRowsCalls gets all the calls that were made to StreamCSVRows.
// Check the length with:
//     len(mockedStorer.StreamCSVRowsCalls())
func (mock *StorerMock) StreamCSVRowsCalls() []struct {
	Ctx    context.Context
	Filter *observation.Filter
	Limit  *int
} {
	var calls []struct {
		Ctx    context.Context
		Filter *observation.Filter
		Limit  *int
	}
	lockStorerMockStreamCSVRows.RLock()
	calls = mock.calls.StreamCSVRows
	lockStorerMockStreamCSVRows.RUnlock()
	return calls
}

// UpdateBuildHierarchyTaskState calls UpdateBuildHierarchyTaskStateFunc.
func (mock *StorerMock) UpdateBuildHierarchyTaskState(id string, dimension string, state string) error {
	if mock.UpdateBuildHierarchyTaskStateFunc == nil {
		panic("StorerMock.UpdateBuildHierarchyTaskStateFunc: method is nil but Storer.UpdateBuildHierarchyTaskState was just called")
	}
	callInfo := struct {
		ID        string
		Dimension string
		State     string
	}{
		ID:        id,
		Dimension: dimension,
		State:     state,
	}
	lockStorerMockUpdateBuildHierarchyTaskState.Lock()
	mock.calls.UpdateBuildHierarchyTaskState = append(mock.calls.UpdateBuildHierarchyTaskState, callInfo)
	lockStorerMockUpdateBuildHierarchyTaskState.Unlock()
	return mock.UpdateBuildHierarchyTaskStateFunc(id, dimension, state)
}

// UpdateBuildHierarchyTaskStateCalls gets all the calls that were made to UpdateBuildHierarchyTaskState.
// Check the length with:
//     len(mockedStorer.UpdateBuildHierarchyTaskStateCalls())
func (mock *StorerMock) UpdateBuildHierarchyTaskStateCalls() []struct {
	ID        string
	Dimension string
	State     string
} {
	var calls []struct {
		ID        string
		Dimension string
		State     string
	}
	lockStorerMockUpdateBuildHierarchyTaskState.RLock()
	calls = mock.calls.UpdateBuildHierarchyTaskState
	lockStorerMockUpdateBuildHierarchyTaskState.RUnlock()
	return calls
}

// UpdateBuildSearchTaskState calls UpdateBuildSearchTaskStateFunc.
func (mock *StorerMock) UpdateBuildSearchTaskState(id string, dimension string, state string) error {
	if mock.UpdateBuildSearchTaskStateFunc == nil {
		panic("StorerMock.UpdateBuildSearchTaskStateFunc: method is nil but Storer.UpdateBuildSearchTaskState was just called")
	}
	callInfo := struct {
		ID        string
		Dimension string
		State     string
	}{
		ID:        id,
		Dimension: dimension,
		State:     state,
	}
	lockStorerMockUpdateBuildSearchTaskState.Lock()
	mock.calls.UpdateBuildSearchTaskState = append(mock.calls.UpdateBuildSearchTaskState, callInfo)
	lockStorerMockUpdateBuildSearchTaskState.Unlock()
	return mock.UpdateBuildSearchTaskStateFunc(id, dimension, state)
}

// UpdateBuildSearchTaskStateCalls gets all the calls that were made to UpdateBuildSearchTaskState.
// Check the length with:
//     len(mockedStorer.UpdateBuildSearchTaskStateCalls())
func (mock *StorerMock) UpdateBuildSearchTaskStateCalls() []struct {
	ID        string
	Dimension string
	State     string
} {
	var calls []struct {
		ID        string
		Dimension string
		State     string
	}
	lockStorerMockUpdateBuildSearchTaskState.RLock()
	calls = mock.calls.UpdateBuildSearchTaskState
	lockStorerMockUpdateBuildSearchTaskState.RUnlock()
	return calls
}

// UpdateDataset calls UpdateDatasetFunc.
func (mock *StorerMock) UpdateDataset(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error {
	if mock.UpdateDatasetFunc == nil {
		panic("StorerMock.UpdateDatasetFunc: method is nil but Storer.UpdateDataset was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ID           string
		Dataset      *models.Dataset
		CurrentState string
	}{
		Ctx:          ctx,
		ID:           ID,
		Dataset:      dataset,
		CurrentState: currentState,
	}
	lockStorerMockUpdateDataset.Lock()
	mock.calls.UpdateDataset = append(mock.calls.UpdateDataset, callInfo)
	lockStorerMockUpdateDataset.Unlock()
	return mock.UpdateDatasetFunc(ctx, ID, dataset, currentState)
}

// UpdateDatasetCalls gets all the calls that were made to UpdateDataset.
// Check the length with:
//     len(mockedStorer.UpdateDatasetCalls())
func (mock *StorerMock) UpdateDatasetCalls() []struct {
	Ctx          context.Context
	ID           string
	Dataset      *models.Dataset
	CurrentState string
} {
	var calls []struct {
		Ctx          context.Context
		ID           string
		Dataset      *models.Dataset
		CurrentState string
	}
	lockStorerMockUpdateDataset.RLock()
	calls = mock.calls.UpdateDataset
	lockStorerMockUpdateDataset.RUnlock()
	return calls
}

// UpdateDatasetWithAssociation calls UpdateDatasetWithAssociationFunc.
func (mock *StorerMock) UpdateDatasetWithAssociation(ID string, state string, version *models.Version) error {
	if mock.UpdateDatasetWithAssociationFunc == nil {
		panic("StorerMock.UpdateDatasetWithAssociationFunc: method is nil but Storer.UpdateDatasetWithAssociation was just called")
	}
	callInfo := struct {
		ID      string
		State   string
		Version *models.Version
	}{
		ID:      ID,
		State:   state,
		Version: version,
	}
	lockStorerMockUpdateDatasetWithAssociation.Lock()
	mock.calls.UpdateDatasetWithAssociation = append(mock.calls.UpdateDatasetWithAssociation, callInfo)
	lockStorerMockUpdateDatasetWithAssociation.Unlock()
	return mock.UpdateDatasetWithAssociationFunc(ID, state, version)
}

// UpdateDatasetWithAssociationCalls gets all the calls that were made to UpdateDatasetWithAssociation.
// Check the length with:
//     len(mockedStorer.UpdateDatasetWithAssociationCalls())
func (mock *StorerMock) UpdateDatasetWithAssociationCalls() []struct {
	ID      string
	State   string
	Version *models.Version
} {
	var calls []struct {
		ID      string
		State   string
		Version *models.Version
	}
	lockStorerMockUpdateDatasetWithAssociation.RLock()
	calls = mock.calls.UpdateDatasetWithAssociation
	lockStorerMockUpdateDatasetWithAssociation.RUnlock()
	return calls
}

// UpdateDimensionNodeID calls UpdateDimensionNodeIDFunc.
func (mock *StorerMock) UpdateDimensionNodeID(dimension *models.DimensionOption) error {
	if mock.UpdateDimensionNodeIDFunc == nil {
		panic("StorerMock.UpdateDimensionNodeIDFunc: method is nil but Storer.UpdateDimensionNodeID was just called")
	}
	callInfo := struct {
		Dimension *models.DimensionOption
	}{
		Dimension: dimension,
	}
	lockStorerMockUpdateDimensionNodeID.Lock()
	mock.calls.UpdateDimensionNodeID = append(mock.calls.UpdateDimensionNodeID, callInfo)
	lockStorerMockUpdateDimensionNodeID.Unlock()
	return mock.UpdateDimensionNodeIDFunc(dimension)
}

// UpdateDimensionNodeIDCalls gets all the calls that were made to UpdateDimensionNodeID.
// Check the length with:
//     len(mockedStorer.UpdateDimensionNodeIDCalls())
func (mock *StorerMock) UpdateDimensionNodeIDCalls() []struct {
	Dimension *models.DimensionOption
} {
	var calls []struct {
		Dimension *models.DimensionOption
	}
	lockStorerMockUpdateDimensionNodeID.RLock()
	calls = mock.calls.UpdateDimensionNodeID
	lockStorerMockUpdateDimensionNodeID.RUnlock()
	return calls
}

// UpdateImportObservationsTaskState calls UpdateImportObservationsTaskStateFunc.
func (mock *StorerMock) UpdateImportObservationsTaskState(id string, state string) error {
	if mock.UpdateImportObservationsTaskStateFunc == nil {
		panic("StorerMock.UpdateImportObservationsTaskStateFunc: method is nil but Storer.UpdateImportObservationsTaskState was just called")
	}
	callInfo := struct {
		ID    string
		State string
	}{
		ID:    id,
		State: state,
	}
	lockStorerMockUpdateImportObservationsTaskState.Lock()
	mock.calls.UpdateImportObservationsTaskState = append(mock.calls.UpdateImportObservationsTaskState, callInfo)
	lockStorerMockUpdateImportObservationsTaskState.Unlock()
	return mock.UpdateImportObservationsTaskStateFunc(id, state)
}

// UpdateImportObservationsTaskStateCalls gets all the calls that were made to UpdateImportObservationsTaskState.
// Check the length with:
//     len(mockedStorer.UpdateImportObservationsTaskStateCalls())
func (mock *StorerMock) UpdateImportObservationsTaskStateCalls() []struct {
	ID    string
	State string
} {
	var calls []struct {
		ID    string
		State string
	}
	lockStorerMockUpdateImportObservationsTaskState.RLock()
	calls = mock.calls.UpdateImportObservationsTaskState
	lockStorerMockUpdateImportObservationsTaskState.RUnlock()
	return calls
}

// UpdateInstance calls UpdateInstanceFunc.
func (mock *StorerMock) UpdateInstance(ctx context.Context, ID string, instance *models.Instance) error {
	if mock.UpdateInstanceFunc == nil {
		panic("StorerMock.UpdateInstanceFunc: method is nil but Storer.UpdateInstance was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ID       string
		Instance *models.Instance
	}{
		Ctx:      ctx,
		ID:       ID,
		Instance: instance,
	}
	lockStorerMockUpdateInstance.Lock()
	mock.calls.UpdateInstance = append(mock.calls.UpdateInstance, callInfo)
	lockStorerMockUpdateInstance.Unlock()
	return mock.UpdateInstanceFunc(ctx, ID, instance)
}

// UpdateInstanceCalls gets all the calls that were made to UpdateInstance.
// Check the length with:
//     len(mockedStorer.UpdateInstanceCalls())
func (mock *StorerMock) UpdateInstanceCalls() []struct {
	Ctx      context.Context
	ID       string
	Instance *models.Instance
} {
	var calls []struct {
		Ctx      context.Context
		ID       string
		Instance *models.Instance
	}
	lockStorerMockUpdateInstance.RLock()
	calls = mock.calls.UpdateInstance
	lockStorerMockUpdateInstance.RUnlock()
	return calls
}

// UpdateObservationInserted calls UpdateObservationInsertedFunc.
func (mock *StorerMock) UpdateObservationInserted(ID string, observationInserted int64) error {
	if mock.UpdateObservationInsertedFunc == nil {
		panic("StorerMock.UpdateObservationInsertedFunc: method is nil but Storer.UpdateObservationInserted was just called")
	}
	callInfo := struct {
		ID                  string
		ObservationInserted int64
	}{
		ID:                  ID,
		ObservationInserted: observationInserted,
	}
	lockStorerMockUpdateObservationInserted.Lock()
	mock.calls.UpdateObservationInserted = append(mock.calls.UpdateObservationInserted, callInfo)
	lockStorerMockUpdateObservationInserted.Unlock()
	return mock.UpdateObservationInsertedFunc(ID, observationInserted)
}

// UpdateObservationInsertedCalls gets all the calls that were made to UpdateObservationInserted.
// Check the length with:
//     len(mockedStorer.UpdateObservationInsertedCalls())
func (mock *StorerMock) UpdateObservationInsertedCalls() []struct {
	ID                  string
	ObservationInserted int64
} {
	var calls []struct {
		ID                  string
		ObservationInserted int64
	}
	lockStorerMockUpdateObservationInserted.RLock()
	calls = mock.calls.UpdateObservationInserted
	lockStorerMockUpdateObservationInserted.RUnlock()
	return calls
}

// UpdateVersion calls UpdateVersionFunc.
func (mock *StorerMock) UpdateVersion(ID string, version *models.Version) error {
	if mock.UpdateVersionFunc == nil {
		panic("StorerMock.UpdateVersionFunc: method is nil but Storer.UpdateVersion was just called")
	}
	callInfo := struct {
		ID      string
		Version *models.Version
	}{
		ID:      ID,
		Version: version,
	}
	lockStorerMockUpdateVersion.Lock()
	mock.calls.UpdateVersion = append(mock.calls.UpdateVersion, callInfo)
	lockStorerMockUpdateVersion.Unlock()
	return mock.UpdateVersionFunc(ID, version)
}

// UpdateVersionCalls gets all the calls that were made to UpdateVersion.
// Check the length with:
//     len(mockedStorer.UpdateVersionCalls())
func (mock *StorerMock) UpdateVersionCalls() []struct {
	ID      string
	Version *models.Version
} {
	var calls []struct {
		ID      string
		Version *models.Version
	}
	lockStorerMockUpdateVersion.RLock()
	calls = mock.calls.UpdateVersion
	lockStorerMockUpdateVersion.RUnlock()
	return calls
}

// UpsertContact calls UpsertContactFunc.
func (mock *StorerMock) UpsertContact(ID string, update interface{}) error {
	if mock.UpsertContactFunc == nil {
		panic("StorerMock.UpsertContactFunc: method is nil but Storer.UpsertContact was just called")
	}
	callInfo := struct {
		ID     string
		Update interface{}
	}{
		ID:     ID,
		Update: update,
	}
	lockStorerMockUpsertContact.Lock()
	mock.calls.UpsertContact = append(mock.calls.UpsertContact, callInfo)
	lockStorerMockUpsertContact.Unlock()
	return mock.UpsertContactFunc(ID, update)
}

// UpsertContactCalls gets all the calls that were made to UpsertContact.
// Check the length with:
//     len(mockedStorer.UpsertContactCalls())
func (mock *StorerMock) UpsertContactCalls() []struct {
	ID     string
	Update interface{}
} {
	var calls []struct {
		ID     string
		Update interface{}
	}
	lockStorerMockUpsertContact.RLock()
	calls = mock.calls.UpsertContact
	lockStorerMockUpsertContact.RUnlock()
	return calls
}

// UpsertDataset calls UpsertDatasetFunc.
func (mock *StorerMock) UpsertDataset(ID string, datasetDoc *models.DatasetUpdate) error {
	if mock.UpsertDatasetFunc == nil {
		panic("StorerMock.UpsertDatasetFunc: method is nil but Storer.UpsertDataset was just called")
	}
	callInfo := struct {
		ID         string
		DatasetDoc *models.DatasetUpdate
	}{
		ID:         ID,
		DatasetDoc: datasetDoc,
	}
	lockStorerMockUpsertDataset.Lock()
	mock.calls.UpsertDataset = append(mock.calls.UpsertDataset, callInfo)
	lockStorerMockUpsertDataset.Unlock()
	return mock.UpsertDatasetFunc(ID, datasetDoc)
}

// UpsertDatasetCalls gets all the calls that were made to UpsertDataset.
// Check the length with:
//     len(mockedStorer.UpsertDatasetCalls())
func (mock *StorerMock) UpsertDatasetCalls() []struct {
	ID         string
	DatasetDoc *models.DatasetUpdate
} {
	var calls []struct {
		ID         string
		DatasetDoc *models.DatasetUpdate
	}
	lockStorerMockUpsertDataset.RLock()
	calls = mock.calls.UpsertDataset
	lockStorerMockUpsertDataset.RUnlock()
	return calls
}

// UpsertEdition calls UpsertEditionFunc.
func (mock *StorerMock) UpsertEdition(datasetID string, edition string, editionDoc *models.EditionUpdate) error {
	if mock.UpsertEditionFunc == nil {
		panic("StorerMock.UpsertEditionFunc: method is nil but Storer.UpsertEdition was just called")
	}
	callInfo := struct {
		DatasetID  string
		Edition    string
		EditionDoc *models.EditionUpdate
	}{
		DatasetID:  datasetID,
		Edition:    edition,
		EditionDoc: editionDoc,
	}
	lockStorerMockUpsertEdition.Lock()
	mock.calls.UpsertEdition = append(mock.calls.UpsertEdition, callInfo)
	lockStorerMockUpsertEdition.Unlock()
	return mock.UpsertEditionFunc(datasetID, edition, editionDoc)
}

// UpsertEditionCalls gets all the calls that were made to UpsertEdition.
// Check the length with:
//     len(mockedStorer.UpsertEditionCalls())
func (mock *StorerMock) UpsertEditionCalls() []struct {
	DatasetID  string
	Edition    string
	EditionDoc *models.EditionUpdate
} {
	var calls []struct {
		DatasetID  string
		Edition    string
		EditionDoc *models.EditionUpdate
	}
	lockStorerMockUpsertEdition.RLock()
	calls = mock.calls.UpsertEdition
	lockStorerMockUpsertEdition.RUnlock()
	return calls
}

// UpsertVersion calls UpsertVersionFunc.
func (mock *StorerMock) UpsertVersion(ID string, versionDoc *models.Version) error {
	if mock.UpsertVersionFunc == nil {
		panic("StorerMock.UpsertVersionFunc: method is nil but Storer.UpsertVersion was just called")
	}
	callInfo := struct {
		ID         string
		VersionDoc *models.Version
	}{
		ID:         ID,
		VersionDoc: versionDoc,
	}
	lockStorerMockUpsertVersion.Lock()
	mock.calls.UpsertVersion = append(mock.calls.UpsertVersion, callInfo)
	lockStorerMockUpsertVersion.Unlock()
	return mock.UpsertVersionFunc(ID, versionDoc)
}

// UpsertVersionCalls gets all the calls that were made to UpsertVersion.
// Check the length with:
//     len(mockedStorer.UpsertVersionCalls())
func (mock *StorerMock) UpsertVersionCalls() []struct {
	ID         string
	VersionDoc *models.Version
} {
	var calls []struct {
		ID         string
		VersionDoc *models.Version
	}
	lockStorerMockUpsertVersion.RLock()
	calls = mock.calls.UpsertVersion
	lockStorerMockUpsertVersion.RUnlock()
	return calls
}
